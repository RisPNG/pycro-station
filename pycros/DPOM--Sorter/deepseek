import os
import re
import threading
from datetime import datetime, date, timedelta
from typing import List, Tuple, Any, Optional, Dict, Set
from dataclasses import dataclass
from collections import defaultdict, OrderedDict
import copy

from PySide6.QtCore import Qt, Signal
from PySide6.QtWidgets import (
    QFileDialog,
    QHBoxLayout,
    QVBoxLayout,
    QLabel,
    QTextEdit,
    QWidget,
    QSizePolicy
)
from qfluentwidgets import PrimaryPushButton, MessageBox

from openpyxl import Workbook, load_workbook
from openpyxl.styles import Alignment, Border, Side, PatternFill, Font, NamedStyle
from openpyxl.utils import get_column_letter
from openpyxl.worksheet.worksheet import Worksheet
from openpyxl.worksheet.dimensions import ColumnDimension, RowDimension

try:
    import xlrd  # for legacy excel
except Exception:
    xlrd = None

# Constants matching VBA colors exactly
COLORS = {
    'DMAGENTA': '800080',      # 8388736
    'CYAN': '00FFFF',          # 16776960
    'PINK': 'C41E3A',          # 12830955
    'GREEN': '7E00A5',         # 8252325
    'YELLOW': 'B8FEFE',        # 12123902
    'DGREEN': '005080',        # 5287936
    'DARKBLUE': '0080A7',      # 16737792
    'ORANGE': '3333FF',        # 3368703
    'WHITE': 'FFFFFF',
    'BLACK': '000000'
}

@dataclass
class UserDefined:
    sc: str = ""  # season code
    bbj: str = ""  # blind buy job

class DPOMProcessor:
    def __init__(self, log_callback):
        self.log = log_callback
        self.colors = COLORS

        # Column definitions (exactly matching VBA)
        self.col_vendor = 1
        self.col_season_code = 2
        self.col_season_year = 3
        self.col_style = 4
        self.col_po = 7
        self.col_trading_co_po = 8
        self.col_po_line = 9
        self.col_ogac = 11
        self.col_doc_type_code = 15
        self.col_transportation = 17
        self.col_ship_to_cus_no = 18
        self.col_ship_to_cus_name = 19
        self.col_country = 20
        self.col_inventory_segment_code = 21
        self.col_sub_category_desc = 23
        self.col_size_desc = 24
        self.col_size_qty = 25
        self.col_total_size_qty = 26
        self.col_fob = 27

        self.max_row = 0
        self.max_col = 0
        self.start_row = 4  # VBA starts at row 4
        self.size_col_start = 0
        self.col_ptr = 0

        self.blind_buy_col = []
        self.size_master = []

        # Worksheets
        self.ws_dpom = None
        self.ws_result = None
        self.ws_temp = None
        self.wb_dpom = None

    def log_step(self, step_name, current=None, total=None):
        if current and total:
            self.log(f"{step_name}: {current}/{total} ({current/total*100:.1f}%)")
        else:
            self.log(f"{step_name}...")

    def process_ss(self, dpom_file_path, size_file_path):
        """Main processing function - exact equivalent of ProcessSS in VBA"""
        try:
            self.log_step("Starting DPOM Sorting Process")

            # Load size master data
            self._load_size_master(size_file_path)

            # Load blind buy data
            self._load_blind_buy_data(size_file_path)

            # Load DPOM workbook
            self.wb_dpom = load_workbook(dpom_file_path)
            self.ws_dpom = self.wb_dpom.active

            # Check if already processed
            if self._check_processed():
                self.log("File already processed. Skipping.")
                return False

            # Check file format
            if not self._check_file_dpom():
                self.log("Invalid file format.")
                return False

            # Create result sheet (copy of original)
            self.ws_result = self.wb_dpom.copy_worksheet(self.ws_dpom)
            self.ws_result.title = f"{self.ws_dpom.title}-copy"

            # Create temp sheet
            self.ws_temp = self.wb_dpom.create_sheet("Temp")

            # Perform all processing steps exactly as in VBA
            self.log_step("1. Sort Record")
            self._sort_record()

            self.log_step("2. Rearrange Size Col")
            self._rearrange_size_col()

            self.log_step("3. First Pass")
            self._first_pass()

            self.log_step("4. Second Pass")
            self._second_pass()

            self.log_step("5. Add New Column")
            self._add_new_column()

            self.log_step("6. Remove Column")
            self._remove_column()

            self.log_step("7. Revert To OBS")
            self._revert_to_obs()

            # Mark as processed exactly like VBA
            self.ws_dpom.cell(1, 27).value = "PROCESSED"  # Column AA
            self.ws_dpom.cell(1, 27).font = Font(color="FFFFFF")
            self.ws_result.cell(1, 1).value = "PROCESSED"

            # Auto-fit columns
            self.max_col = self._get_max_col(self.ws_result)
            for col in range(1, self.max_col + 1):
                col_letter = get_column_letter(col)
                self.ws_result.column_dimensions[col_letter].width = 15

            # Run module 2 functionality
            self.log_step("8. Separate Data Groups")
            self._separate_data_groups()

            # Clean up temp sheet
            self.wb_dpom.remove(self.ws_temp)

            self.log_step("Process completed successfully")
            return True

        except Exception as e:
            self.log(f"Error during processing: {str(e)}")
            import traceback
            self.log(f"Traceback: {traceback.format_exc()}")
            return False

    def _load_size_master(self, size_file_path):
        """Load size master data from size sheet - exact VBA equivalent"""
        try:
            size_wb = load_workbook(size_file_path)
            if "Size" not in size_wb.sheetnames:
                self.log("Size sheet not found")
                return

            size_ws = size_wb["Size"]

            self.size_master = []
            row = 2
            while size_ws.cell(row, 1).value is not None:
                size_val = str(size_ws.cell(row, 1).value).strip()
                if size_val:
                    self.size_master.append(size_val)
                row += 1

            self.log(f"Loaded {len(self.size_master)} size entries from Size sheet")
            size_wb.close()

        except Exception as e:
            self.log(f"Error loading size master: {e}")
            self.size_master = []

    def _load_blind_buy_data(self, size_file_path):
        """Load blind buy data from Blind Buy sheet - exact VBA equivalent"""
        try:
            bb_wb = load_workbook(size_file_path)
            if "Blind Buy" not in bb_wb.sheetnames:
                self.log("Blind Buy sheet not found")
                return

            bb_ws = bb_wb["Blind Buy"]

            self.blind_buy_col = []
            row = 2
            while bb_ws.cell(row, 1).value is not None:
                ud = UserDefined()
                ud.sc = str(bb_ws.cell(row, 1).value).strip().upper()
                ud.bbj = str(bb_ws.cell(row, 2).value).strip()
                self.blind_buy_col.append(ud)
                row += 1

            self.log(f"Loaded {len(self.blind_buy_col)} blind buy entries from Blind Buy sheet")
            bb_wb.close()

        except Exception as e:
            self.log(f"Error loading blind buy data: {e}")
            self.blind_buy_col = []

    def _check_processed(self):
        """Check if file has already been processed - exact VBA equivalent"""
        return self.ws_dpom.cell(1, 27).value == "PROCESSED"  # Column AA

    def _check_file_dpom(self):
        """Validate DPOM file format - exact VBA equivalent"""
        try:
            headers = {
                self.col_vendor: "Vendor Code",
                self.col_season_code: "Planning Season Code",
                self.col_season_year: "Planning Season Year",
                self.col_style: "Product Code",
                self.col_po: "Purchase Order Number",
                self.col_trading_co_po: "Trading Co PO Number",
                self.col_po_line: "PO Line Item Number",
                self.col_ogac: "OGAC",
                self.col_doc_type_code: "Doc Type Code",
                self.col_transportation: "Mode of Transportation Code",
                self.col_ship_to_cus_no: "Ship To Customer Number",
                self.col_ship_to_cus_name: "Ship To Customer Name",
                self.col_country: "Destination Country",
                self.col_inventory_segment_code: "Inventory Segment Code",
                self.col_sub_category_desc: "Sub Category Description",
                self.col_size_desc: "Size Description",
                self.col_size_qty: "Size Quantity",
                self.col_total_size_qty: "Total Item Quantity",
                self.col_fob: "Gross Price/FOB"
            }

            for col, expected_header in headers.items():
                actual = str(self.ws_dpom.cell(1, col).value or "").strip()
                if actual != expected_header:
                    self.log(f"Header mismatch at column {col}: expected '{expected_header}', got '{actual}'")
                    return False

            return True

        except Exception as e:
            self.log(f"Error checking file format: {e}")
            return False

    def _normalize_size(self, size_val):
        """Normalize size string for consistent comparison - exact VBA equivalent"""
        if size_val is None:
            return ""

        temp_size = str(size_val).strip().upper()

        # Remove dashes exactly like VBA
        temp_size = temp_size.replace("-", "")

        # Standardize X sizing exactly like VBA
        replacements = [
            ("XXXXXL", "6XL"),
            ("XXXXL", "5XL"),
            ("XXXXL", "4XL"),
            ("XXXL", "3XL"),
            ("XXL", "2XL"),
            ("XXXXXS", "6XS"),
            ("XXXXS", "5XS"),
            ("XXXS", "4XS"),
            ("XXXS", "3XS"),
            ("XXS", "2XS")
        ]

        for old, new in replacements:
            temp_size = temp_size.replace(old, new)

        return temp_size

    def _sort_record(self):
        """Sort records based on multiple criteria - exact VBA equivalent"""
        self.log_step("Sorting records")

        # Get data bounds exactly like VBA
        self.max_col = self._get_max_col(self.ws_result)
        self.max_row = self.ws_result.max_row

        if self.max_row < self.start_row:
            return

        n_rows = self.max_row - self.start_row + 1

        # Read data into memory for performance
        data = []
        for row in range(self.start_row, self.max_row + 1):
            row_data = {
                'style': str(self.ws_result.cell(row, self.col_style).value or ""),
                'ogac': str(self.ws_result.cell(row, self.col_ogac).value or ""),
                'season_code': str(self.ws_result.cell(row, self.col_season_code).value or ""),
                'season_year': self.ws_result.cell(row, self.col_season_year).value,
                'po': self.ws_result.cell(row, self.col_po).value,
                'po_line': self.ws_result.cell(row, self.col_po_line).value,
                'country': str(self.ws_result.cell(row, self.col_country).value or ""),
                'ship_to_cus_no': str(self.ws_result.cell(row, self.col_ship_to_cus_no).value or ""),
                'original_row': row,
                'all_data': [self.ws_result.cell(row, col).value for col in range(1, self.max_col + 1)]
            }
            data.append(row_data)

        # Prepare sort keys exactly like VBA
        for item in data:
            # Style head (first 6 chars)
            style = item['style']
            if len(style) >= 6:
                item['style_head'] = style[:6]
            else:
                item['style_head'] = style

            # OGAC date key (yyyymmdd)
            ogac = item['ogac']
            if "/" in ogac:
                parts = ogac.split("/")
                if len(parts) >= 3:
                    yy = parts[2][-4:] if len(parts[2]) >= 4 else parts[2]
                    mm = str(int(parts[0])).zfill(2) if parts[0].isdigit() else parts[0].zfill(2)
                    dd = str(int(parts[1])).zfill(2) if parts[1].isdigit() else parts[1].zfill(2)
                    item['ogac_key'] = yy + mm + dd
                else:
                    item['ogac_key'] = ogac[-4:] if len(ogac) >= 4 else ogac
            else:
                item['ogac_key'] = ogac[-4:] if len(ogac) >= 4 else ogac

            # Colorway (last 3 chars)
            if len(style) >= 3:
                item['colorway'] = style[-3:]
            else:
                item['colorway'] = style

            # Season rank
            season = item['season_code'].upper()
            season_rank_map = {"SP": "1", "SU": "2", "FA": "3", "HO": "4"}
            item['season_rank'] = season_rank_map.get(season, "")

        # Sort exactly like VBA
        data.sort(key=lambda x: (
            x['style_head'] or "",
            str(x['season_year']) or "",
            x['season_rank'] or "",
            x['ogac_key'] or "",
            str(x['po']) or "",
            x['colorway'] or "",
            str(x['po_line']) or "",
            x['country'] or "",
            x['ship_to_cus_no'] or ""
        ))

        # Write sorted data back
        for i, item in enumerate(data):
            row = self.start_row + i
            for col, value in enumerate(item['all_data'], 1):
                self.ws_result.cell(row, col).value = value

        # Clear any fill on sorted area exactly like VBA
        for row in range(self.start_row, self.max_row + 1):
            for col in range(1, self.max_col + 1):
                self.ws_result.cell(row, col).fill = PatternFill(fill_type=None)

    def _rearrange_size_col(self):
        """Rearrange size columns based on master size list - exact VBA equivalent"""
        self.log_step("Rearranging size columns")

        self.max_col = self._get_max_col(self.ws_result)
        self.size_col_start = self.max_col + 1
        self.max_row = self.ws_result.max_row

        # Remove duplicate size descriptions exactly like VBA
        unique_sizes = set()
        for row in range(self.start_row, self.max_row + 1):
            size_desc = str(self.ws_result.cell(row, self.col_size_desc).value or "").strip()
            if size_desc:
                unique_sizes.add(size_desc)

        # Write unique sizes to temp sheet exactly like VBA
        temp_sizes = list(unique_sizes)
        for i, size in enumerate(temp_sizes, 1):
            self.ws_temp.cell(i, 1).value = size

        # Sort sizes according to master list exactly like VBA
        sorted_sizes = []
        remaining_sizes = list(unique_sizes)

        # First add sizes in master order
        for master_size in self.size_master:
            normalized_master = self._normalize_size(master_size)
            for i, size in enumerate(remaining_sizes):
                if self._normalize_size(size) == normalized_master:
                    sorted_sizes.append(size)
                    remaining_sizes.pop(i)
                    break

        # Add remaining sizes
        sorted_sizes.extend(remaining_sizes)

        # Populate size headers exactly like VBA
        for i, size in enumerate(sorted_sizes):
            self.ws_result.cell(1, self.size_col_start + i).value = size.strip()
            self.log_step(f"Adding size column: {size}", i, len(sorted_sizes))

    def _first_pass(self):
        """First pass grouping by item characteristics - exact VBA equivalent"""
        self.log_step("First pass grouping")

        self.max_col = self._get_max_col(self.ws_result)
        self.max_row = self.ws_result.max_row

        # Build size map for fast lookup
        size_map = {}
        for col in range(self.size_col_start, self.max_col + 1):
            header = str(self.ws_result.cell(1, col).value or "").strip()
            if header:
                normalized = self._normalize_size(header)
                size_map[normalized] = col

        # Insert overall result column exactly like VBA
        overall_col = self.max_col + 1
        self.ws_result.cell(1, overall_col).value = "Overall Result"
        self.ws_result.cell(self.max_row + 1, 1).value = "Overall Result"
        self.ws_result.cell(self.max_row + 1, overall_col + 1).value = "Total Item Qty"

        start_ptr = self.start_row
        current_row = self.start_row

        while current_row < self.max_row:
            if current_row % 100 == 0:
                self.log_step("First pass processing", current_row, self.max_row)

            # Get current and next row values exactly like VBA
            curr_vals = self._get_row_values(current_row)
            next_vals = self._get_row_values(current_row + 1)

            # Check if rows don't match exactly like VBA
            if not self._rows_match(curr_vals, next_vals):
                end_ptr = current_row

                # Insert 2 new rows exactly like VBA
                self.ws_result.insert_rows(end_ptr + 1, 2)
                self.max_row += 2

                # Copy original row to new positions exactly like VBA
                self._copy_row(end_ptr, end_ptr + 1)
                self._copy_row(end_ptr, end_ptr + 2)

                # Set labels exactly like VBA
                self.ws_result.cell(end_ptr, overall_col + 1).value = "Total Item Qty"
                self.ws_result.cell(end_ptr + 1, overall_col + 1).value = "Trading Co Net Unit Price"
                self.ws_result.cell(end_ptr + 2, overall_col + 1).value = "Net Unit Price"

                # Group data exactly like VBA
                row_ptr = start_ptr
                while row_ptr <= end_ptr:
                    if self.ws_result.cell(row_ptr, overall_col + 1).value != "Total Item Qty":
                        size_desc = str(self.ws_result.cell(row_ptr, self.col_size_desc).value or "")
                        size_qty = self.ws_result.cell(row_ptr, self.col_size_qty).value
                        fob = self.ws_result.cell(row_ptr, self.col_fob).value

                        normalized_size = self._normalize_size(size_desc)

                        if normalized_size in size_map:
                            target_col = size_map[normalized_size]
                            self.ws_result.cell(end_ptr, target_col).value = size_qty
                            self.ws_result.cell(end_ptr + 1, target_col).value = fob
                            self.ws_result.cell(end_ptr + 2, target_col).value = fob
                        else:
                            # Fallback search exactly like VBA
                            for col in range(self.size_col_start, self.max_col + 1):
                                header = str(self.ws_result.cell(1, col).value or "")
                                if self._normalize_size(header) == normalized_size:
                                    self.ws_result.cell(end_ptr, col).value = size_qty
                                    self.ws_result.cell(end_ptr + 1, col).value = fob
                                    self.ws_result.cell(end_ptr + 2, col).value = fob
                                    break

                    row_ptr += 1

                # Set total size quantity exactly like VBA
                total = 0
                for col in range(self.size_col_start, self.max_col + 1):
                    val = self.ws_result.cell(end_ptr, col).value
                    if isinstance(val, (int, float)):
                        total += val
                self.ws_result.cell(end_ptr, overall_col).value = total

                start_ptr = end_ptr + 3
                current_row += 2

            current_row += 1

        # Set column totals exactly like VBA
        total_row = self.max_row + 1
        for col in range(self.size_col_start, overall_col + 1):
            total = 0
            for row in range(self.start_row, self.max_row + 1):
                if self.ws_result.cell(row, overall_col + 1).value == "Total Item Qty":
                    val = self.ws_result.cell(row, col).value
                    if isinstance(val, (int, float)):
                        total += val
            self.ws_result.cell(total_row, col).value = total

        # Clean up empty rows exactly like VBA
        self._cleanup_empty_rows(overall_col + 1)

        # Move column exactly like VBA
        self._move_column(overall_col + 1, self.col_ship_to_cus_no)

        # Delete columns exactly like VBA
        self.ws_result.delete_cols(self.col_size_desc, 4)  # Size Desc through FOB

        # Adjust column references exactly like VBA
        self._adjust_column_references()

    def _second_pass(self):
        """Second pass grouping - exact VBA equivalent with all sub-methods"""
        self.log_step("Second pass grouping")

        # Style grouping
        self._style_grouping()

        # OGAC grouping
        self._ogac_grouping()

        # PO/Country/AFS grouping
        self._po_country_afs_grouping()

        # Colorway grouping
        self._colorway_grouping()

    def _style_grouping(self):
        """Style grouping - exact VBA equivalent"""
        self.log_step("Style grouping")

        self.max_col = self._get_max_col(self.ws_result)
        self.max_row = self.ws_result.max_row

        start_ptr = self.start_row
        current_row = self.start_row

        # Get current style (first part before dash)
        curr_style = self._get_style_head(current_row)
        prev_style = curr_style

        while current_row <= self.max_row:
            if current_row % 50 == 0:
                self.log_step("Style grouping", current_row, self.max_row)

            curr_style = self._get_style_head(current_row)

            # If current and previous style not match
            if curr_style != prev_style:
                end_ptr = current_row - 1

                # Find the last "Total Item Qty" row exactly like VBA
                point = end_ptr
                for row in range(end_ptr, start_ptr - 1, -1):
                    if self.ws_result.cell(row, self.col_ptr).value == "Total Item Qty":
                        point = row
                        break

                # Insert 4 rows exactly like VBA
                self.ws_result.insert_rows(current_row, 4)
                self.max_row += 4

                # Copy and format rows exactly like VBA
                self._copy_row(point + 1, current_row + 1)
                self._copy_row(point + 2, current_row + 2)
                self._copy_row(point, current_row)

                # Set labels and format exactly like VBA
                self.ws_result.cell(current_row, self.col_ptr).value = "Total Style Qty"

                # Apply green formatting exactly like VBA
                self._apply_formatting_range(current_row, current_row + 2, 1, self.max_col,
                                           fill_color=self.colors['GREEN'], bold=True)

                # Calculate totals exactly like VBA
                total_sum1 = 0
                total_sum2 = 0

                for col in range(self.size_col_start, self.max_col):
                    # Calculate sum for this size column
                    col_sum = 0
                    money1 = 0
                    money2 = 0

                    for row in range(start_ptr, end_ptr + 1):
                        if self.ws_result.cell(row, self.col_ptr).value == "Total Item Qty":
                            val = self.ws_result.cell(row, col).value
                            if isinstance(val, (int, float)):
                                col_sum += val

                            # Get money values
                            money1_val = self.ws_result.cell(row + 1, col).value
                            money2_val = self.ws_result.cell(row + 2, col).value

                            if money1_val and isinstance(money1_val, (int, float)):
                                money1 = money1_val
                            if money2_val and isinstance(money2_val, (int, float)):
                                money2 = money2_val

                    # Set values exactly like VBA
                    self.ws_result.cell(current_row, col).value = col_sum if col_sum != 0 else None
                    self.ws_result.cell(current_row + 1, col).value = money1 if money1 != 0 else None
                    self.ws_result.cell(current_row + 2, col).value = money2 if money2 != 0 else None

                    total_sum1 += col_sum * (money1 or 0)
                    total_sum2 += col_sum * (money2 or 0)

                # Set total values exactly like VBA
                self.ws_result.cell(current_row + 1, self.max_col + 1).value = total_sum1
                self.ws_result.cell(current_row + 2, self.max_col + 1).value = total_sum2

                # Apply green formatting to total cells
                self._apply_formatting_cell(current_row + 1, self.max_col + 1,
                                          fill_color=self.colors['GREEN'], bold=True)
                self._apply_formatting_cell(current_row + 2, self.max_col + 1,
                                          fill_color=self.colors['GREEN'], bold=True)

                # Add separator row exactly like VBA
                self._apply_formatting_range(current_row + 3, current_row + 3, 1, self.max_col,
                                           fill_color=self.colors['DGREEN'])
                self.ws_result.row_dimensions[current_row + 3].height = 5

                # Calculate overall total exactly like VBA
                style_total = 0
                for row in range(start_ptr, end_ptr + 1):
                    if self.ws_result.cell(row, self.col_ptr).value == "Total Item Qty":
                        val = self.ws_result.cell(row, self.max_col).value
                        if isinstance(val, (int, float)):
                            style_total += val

                self.ws_result.cell(current_row, self.max_col).value = style_total

                current_row += 4
                start_ptr = current_row
                prev_style = curr_style

            current_row += 1
            if current_row <= self.max_row:
                curr_style = self._get_style_head(current_row)

    def _ogac_grouping(self):
        """OGAC grouping - exact VBA equivalent"""
        self.log_step("OGAC grouping")

        self.max_col = self._get_max_col(self.ws_result)
        self.max_row = self.ws_result.max_row

        start_ptr = self.start_row
        current_row = self.start_row

        while current_row <= self.max_row:
            if current_row % 50 == 0:
                self.log_step("OGAC grouping", current_row, self.max_row)

            if self.ws_result.cell(current_row, self.col_ptr).value == "Total Style Qty":
                inner_start_ptr = start_ptr
                end_ptr = current_row

                curr_ogac = str(self.ws_result.cell(start_ptr, self.col_ogac).value or "").upper()
                prev_ogac = curr_ogac

                inner_ptr = start_ptr
                while inner_ptr <= end_ptr:
                    curr_ogac = str(self.ws_result.cell(inner_ptr, self.col_ogac).value or "").upper()

                    if curr_ogac != prev_ogac:
                        # Find the last "Total Item Qty" row
                        point = inner_ptr - 1
                        for row in range(inner_ptr - 1, inner_start_ptr - 1, -1):
                            if self.ws_result.cell(row, self.col_ptr).value == "Total Item Qty":
                                point = row
                                break

                        # Insert 2 rows exactly like VBA
                        self.ws_result.insert_rows(inner_ptr, 2)
                        self.max_row += 2
                        end_ptr += 2

                        # Copy and format exactly like VBA
                        self._copy_row(point, inner_ptr)
                        self.ws_result.cell(inner_ptr, self.col_ptr).value = "Total OGAC Qty"

                        # Calculate sums exactly like VBA
                        for col in range(self.size_col_start, self.max_col):
                            col_sum = 0
                            for row in range(inner_start_ptr, inner_ptr):
                                if self.ws_result.cell(row, self.col_ptr).value == "Total Item Qty":
                                    val = self.ws_result.cell(row, col).value
                                    if isinstance(val, (int, float)):
                                        col_sum += val

                            self.ws_result.cell(inner_ptr, col).value = col_sum if col_sum != 0 else None

                        # Apply pink formatting exactly like VBA
                        self._apply_formatting_range(inner_ptr, inner_ptr, 1, self.max_col,
                                                   fill_color=self.colors['PINK'], bold=True)

                        # Add separator row
                        self._apply_formatting_range(inner_ptr + 1, inner_ptr + 1, 1, self.max_col,
                                                   fill_color=self.colors['PINK'])
                        self.ws_result.row_dimensions[inner_ptr + 1].height = 5

                        # Calculate overall total
                        ogac_total = 0
                        for row in range(inner_start_ptr, inner_ptr):
                            if self.ws_result.cell(row, self.col_ptr).value == "Total Item Qty":
                                val = self.ws_result.cell(row, self.max_col).value
                                if isinstance(val, (int, float)):
                                    ogac_total += val

                        self.ws_result.cell(inner_ptr, self.max_col).value = ogac_total

                        inner_start_ptr = inner_ptr + 2
                        inner_ptr += 2

                    inner_ptr += 1
                    if inner_ptr <= self.max_row:
                        curr_ogac = str(self.ws_result.cell(inner_ptr, self.col_ogac).value or "").upper()

                current_row = inner_ptr + 3
                start_ptr = current_row + 1

            current_row += 1

    def _po_country_afs_grouping(self):
        """PO/Country/AFS grouping - exact VBA equivalent"""
        self.log_step("PO/Country/AFS grouping")

        self.max_col = self._get_max_col(self.ws_result)
        self.max_row = self.ws_result.max_row

        start_ptr = self.start_row
        current_row = self.start_row

        while current_row <= self.max_row:
            if current_row % 50 == 0:
                self.log_step("PO/Country/AFS grouping", current_row, self.max_row)

            if self.ws_result.cell(current_row, self.col_ptr).value == "Total OGAC Qty":
                inner_start_ptr = start_ptr
                end_ptr = current_row - 1

                curr_country = str(self.ws_result.cell(start_ptr, self.col_country).value or "").upper()
                prev_country = curr_country
                curr_po = str(self.ws_result.cell(start_ptr, self.col_po).value or "").upper()
                prev_po = curr_po
                curr_afs = str(self.ws_result.cell(start_ptr, self.col_inventory_segment_code).value or "").upper()
                prev_afs = curr_afs
                curr_ship = str(self.ws_result.cell(start_ptr, self.col_ship_to_cus_no).value or "").upper()
                prev_ship = curr_ship

                inner_ptr = start_ptr
                while inner_ptr <= end_ptr:
                    curr_country = str(self.ws_result.cell(inner_ptr, self.col_country).value or "").upper()
                    curr_po = str(self.ws_result.cell(inner_ptr, self.col_po).value or "").upper()
                    curr_afs = str(self.ws_result.cell(inner_ptr, self.col_inventory_segment_code).value or "").upper()
                    curr_ship = str(self.ws_result.cell(inner_ptr, self.col_ship_to_cus_no).value or "").upper()

                    # Check for changes or blind buy conditions exactly like VBA
                    blind_buy_found, bb_job = self._blind_buy_contains(self.ws_result.cell(inner_ptr, self.col_style).value)

                    if (curr_country != prev_country or curr_po != prev_po or
                        blind_buy_found or curr_afs != prev_afs or curr_ship != prev_ship):

                        if blind_buy_found:
                            # Handle blind buy logic exactly like VBA
                            if (not self._blind_buy_contains(self.ws_result.cell(inner_ptr - 1, self.col_style).value)[0] and
                                inner_ptr != self.start_row and
                                self.ws_result.cell(inner_ptr - 1, self.col_ptr).value != ""):

                                self._insert_po_group(inner_start_ptr, inner_ptr, blind_buy=True, bb_job=bb_job)
                                inner_start_ptr = inner_ptr + 4
                                inner_ptr += 4

                            # Insert additional rows for blind buy exactly like VBA
                            self.ws_result.insert_rows(inner_ptr, 4)
                            self.max_row += 4
                            end_ptr += 4

                            # Copy and format blind buy rows
                            self._copy_row(inner_ptr, inner_ptr + 3)
                            self.ws_result.cell(inner_ptr + 3, self.col_ptr).value = "Total PO Qty"

                            self._copy_row(inner_ptr + 1, inner_ptr + 4)
                            self._copy_row(inner_ptr + 2, inner_ptr + 5)

                            # Apply yellow formatting
                            self._apply_formatting_range(inner_ptr + 3, inner_ptr + 5, 1, self.max_col,
                                                       fill_color=self.colors['YELLOW'], bold=True)

                            # Calculate totals for blind buy group
                            total_sum1, total_sum2 = self._calculate_po_totals(inner_start_ptr, inner_ptr + 2)

                            # Set blind buy job number
                            self.ws_result.cell(inner_ptr + 3, 9).value = bb_job
                            self.ws_result.cell(inner_ptr + 4, 9).value = bb_job
                            self.ws_result.cell(inner_ptr + 5, 9).value = bb_job

                            # Add separator
                            self._apply_formatting_range(inner_ptr + 6, inner_ptr + 6, 1, self.max_col,
                                                       fill_color=self.colors['BLACK'])
                            self.ws_result.row_dimensions[inner_ptr + 6].height = 5

                            inner_start_ptr = inner_ptr + 7
                            inner_ptr += 6
                        else:
                            # Regular PO group
                            self._insert_po_group(inner_start_ptr, inner_ptr)
                            inner_start_ptr = inner_ptr + 4
                            inner_ptr += 3

                    inner_ptr += 1
                    if inner_ptr <= self.max_row:
                        curr_country = str(self.ws_result.cell(inner_ptr, self.col_country).value or "").upper()
                        curr_po = str(self.ws_result.cell(inner_ptr, self.col_po).value or "").upper()
                        curr_afs = str(self.ws_result.cell(inner_ptr, self.col_inventory_segment_code).value or "").upper()
                        curr_ship = str(self.ws_result.cell(inner_ptr, self.col_ship_to_cus_no).value or "").upper()

                current_row = inner_ptr + 3
                start_ptr = current_row + 1

            current_row += 1

    def _insert_po_group(self, start_ptr, end_ptr, blind_buy=False, bb_job=""):
        """Insert PO group - exact VBA equivalent"""
        # Find the last "Total Item Qty" row
        point = end_ptr - 1
        for row in range(end_ptr - 1, start_ptr - 1, -1):
            if self.ws_result.cell(row, self.col_ptr).value == "Total Item Qty":
                point = row
                break

        # Insert 3 rows exactly like VBA
        self.ws_result.insert_rows(end_ptr, 3)
        self.max_row += 3

        # Copy and format rows
        self._copy_row(point + 1, end_ptr + 1)
        self._copy_row(point + 2, end_ptr + 2)
        self._copy_row(point, end_ptr)

        # Set PO label
        self.ws_result.cell(end_ptr, self.col_ptr).value = "Total PO Qty"

        # Apply yellow formatting exactly like VBA
        self._apply_formatting_range(end_ptr, end_ptr + 2, 1, self.max_col,
                                   fill_color=self.colors['YELLOW'], bold=True)

        # Calculate totals
        total_sum1, total_sum2 = self._calculate_po_totals(start_ptr, end_ptr)

        # Set total values
        self.ws_result.cell(end_ptr + 1, self.max_col + 1).value = total_sum1
        self.ws_result.cell(end_ptr + 2, self.max_col + 1).value = total_sum2

        # Apply yellow formatting to total cells
        self._apply_formatting_cell(end_ptr + 1, self.max_col + 1,
                                  fill_color=self.colors['YELLOW'], bold=True)
        self._apply_formatting_cell(end_ptr + 2, self.max_col + 1,
                                  fill_color=self.colors['YELLOW'], bold=True)

        # Add separator
        self._apply_formatting_range(end_ptr + 3, end_ptr + 3, 1, self.max_col,
                                   fill_color=self.colors['BLACK'])
        self.ws_result.row_dimensions[end_ptr + 3].height = 5

        # Set blind buy job number if applicable
        if blind_buy and bb_job:
            self.ws_result.cell(end_ptr, 9).value = bb_job
            self.ws_result.cell(end_ptr + 1, 9).value = bb_job
            self.ws_result.cell(end_ptr + 2, 9).value = bb_job

    def _calculate_po_totals(self, start_ptr, end_ptr):
        """Calculate PO totals - exact VBA equivalent"""
        total_sum1 = 0
        total_sum2 = 0

        for col in range(self.size_col_start, self.max_col):
            col_sum = 0
            money1 = 0
            money2 = 0

            for row in range(start_ptr, end_ptr):
                if self.ws_result.cell(row, self.col_ptr).value == "Total Item Qty":
                    val = self.ws_result.cell(row, col).value
                    if isinstance(val, (int, float)):
                        col_sum += val

                    # Get money values from the rows below
                    money1_val = self.ws_result.cell(row + 1, col).value
                    money2_val = self.ws_result.cell(row + 2, col).value

                    if money1_val and isinstance(money1_val, (int, float)):
                        money1 = money1_val
                    if money2_val and isinstance(money2_val, (int, float)):
                        money2 = money2_val

            # Set values in the new PO group rows
            self.ws_result.cell(end_ptr, col).value = col_sum if col_sum != 0 else None
            self.ws_result.cell(end_ptr + 1, col).value = money1 if money1 != 0 else None
            self.ws_result.cell(end_ptr + 2, col).value = money2 if money2 != 0 else None

            total_sum1 += col_sum * (money1 or 0)
            total_sum2 += col_sum * (money2 or 0)

        # Calculate overall total for the PO group
        po_total = 0
        for row in range(start_ptr, end_ptr):
            if self.ws_result.cell(row, self.col_ptr).value == "Total Item Qty":
                val = self.ws_result.cell(row, self.max_col).value
                if isinstance(val, (int, float)):
                    po_total += val

        self.ws_result.cell(end_ptr, self.max_col).value = po_total

        return total_sum1, total_sum2

    def _colorway_grouping(self):
        """Colorway grouping - exact VBA equivalent"""
        self.log_step("Colorway grouping")

        self.max_col = self._get_max_col(self.ws_result)
        self.max_row = self.ws_result.max_row

        start_ptr = self.start_row
        current_row = self.start_row

        curr_colorway = self._get_colorway(current_row)
        prev_colorway = curr_colorway
        cw_count = 0

        while current_row <= self.max_row:
            if current_row % 50 == 0:
                self.log_step("Colorway grouping", current_row, self.max_row)

            curr_colorway = self._get_colorway(current_row)

            if curr_colorway == prev_colorway and self.ws_result.cell(current_row, self.col_ptr).value != "Total PO Qty":
                if self.ws_result.cell(current_row, self.col_ptr).value == "Total Item Qty":
                    cw_count += 1

                current_row += 1
            else:
                # If we have 2 or more colorway rows, insert summary
                if cw_count >= 2:
                    # Find the latest "Total Item Qty" row
                    point = current_row - 1
                    for row in range(current_row - 1, start_ptr - 1, -1):
                        if self.ws_result.cell(row, self.col_ptr).value == "Total Item Qty":
                            point = row
                            break

                    # Insert divider row
                    self.ws_result.insert_rows(current_row)
                    self.max_row += 1

                    # Copy and format
                    self._copy_row(point, current_row)
                    self.ws_result.cell(current_row, self.col_ptr).value = "Total Colorway Qty"

                    # Calculate sums
                    for col in range(self.size_col_start, self.max_col):
                        col_sum = 0
                        for row in range(start_ptr, current_row):
                            if self.ws_result.cell(row, self.col_ptr).value == "Total Item Qty":
                                val = self.ws_result.cell(row, col).value
                                if isinstance(val, (int, float)):
                                    col_sum += val

                        self.ws_result.cell(current_row, col).value = col_sum if col_sum != 0 else None

                    # Apply cyan formatting exactly like VBA
                    self._apply_formatting_range(current_row, current_row, 1, self.max_col,
                                               fill_color=self.colors['CYAN'], bold=True)

                    # Calculate overall total
                    cw_total = 0
                    for row in range(start_ptr, current_row):
                        if self.ws_result.cell(row, self.col_ptr).value == "Total Item Qty":
                            val = self.ws_result.cell(row, self.max_col).value
                            if isinstance(val, (int, float)):
                                cw_total += val

                    self.ws_result.cell(current_row, self.max_col).value = cw_total

                    current_row += 1
                    start_ptr = current_row
                    cw_count = 0

                if self.ws_result.cell(current_row, self.col_ptr).value == "Total PO Qty":
                    current_row += 4
                    if current_row <= self.max_row:
                        curr_colorway = self._get_colorway(current_row)

                prev_colorway = curr_colorway
                start_ptr = current_row
                cw_count = 0

                if current_row <= self.max_row:
                    curr_colorway = self._get_colorway(current_row)

            current_row += 1

    def _separate_data_groups(self):
        """Implement Module 2 functionality - exact VBA equivalent"""
        self.log_step("Separating data groups")

        self.max_col = self._get_max_col(self.ws_result)
        self.max_row = self.ws_result.max_row

        # First Pass - exactly like VBA
        current_row = self.start_row
        start_row = self.start_row

        while current_row <= self.max_row:
            if current_row % 100 == 0:
                self.log_step("First pass data separation", current_row, self.max_row)

            # Check if row is empty in column S (19) exactly like VBA
            if self.ws_result.cell(current_row, 19).value is None:
                end_row = current_row - 1

                # Process data group exactly like VBA
                self._process_data_group(start_row, end_row, self.max_col)

                # Update max row after processing
                self.max_row = self._get_max_col(self.ws_result)

                start_row = current_row + 1
            elif current_row == self.max_row:
                # Process last data group exactly like VBA
                self._process_data_group(start_row, self.max_row, self.max_col)
                self.max_row = self._get_max_col(self.ws_result)

            current_row += 1

        # Second Pass - exactly like VBA
        self.max_row = self._get_max_col(self.ws_result)
        current_row = self.start_row

        while current_row < self.max_row:
            if current_row % 100 == 0:
                self.log_step("Second pass data separation", current_row, self.max_row)

            # Clear contents for "Total PO Qty" in columns AD, AE exactly like VBA
            if self.ws_result.cell(current_row, 24).value == "Total PO Qty":  # Column X
                self.ws_result.cell(current_row, 30).value = None  # Column AD
                self.ws_result.cell(current_row, 31).value = None  # Column AE

            # Check for yellow row followed by white row exactly like VBA
            if (self._get_cell_color(current_row, 1) == self.colors['YELLOW'] and
                self._get_cell_color(current_row + 1, 1) == self.colors['WHITE']):

                # Insert separator row exactly like VBA
                self.ws_result.insert_rows(current_row + 1)
                self.max_row += 1

                # Format separator row exactly like VBA
                for col in range(1, self.max_col + 1):
                    self.ws_result.cell(current_row + 1, col).fill = PatternFill(
                        start_color=self.colors['BLACK'], end_color=self.colors['BLACK'], fill_type="solid")

                self.ws_result.row_dimensions[current_row + 1].height = 5

                current_row += 2
            else:
                current_row += 1

    def _process_data_group(self, start_row, end_row, end_col):
        """Process data group - exact VBA equivalent"""
        self.log_step(f"Processing data group from row {start_row} to {end_row}")

        has_difference = False
        cyan_found = False

        # Check for plant code differential exactly like VBA (column S/19)
        for row in range(start_row + 1, end_row + 1):
            if self.ws_result.cell(row, 19).value != self.ws_result.cell(row - 1, 19).value:
                has_difference = True
                break

        # Identify row colors exactly like VBA
        white_rows = []
        yellow_rows = []

        row = start_row
        while row <= end_row:
            cell_color = self._get_cell_color(row, 1)
            if cell_color == self.colors['WHITE']:
                white_rows.append(row)
            elif cell_color == self.colors['YELLOW']:
                yellow_rows.append(row)
            elif cell_color == self.colors['CYAN']:
                cyan_found = True
                # Delete cyan row exactly like VBA
                self.ws_result.delete_rows(row)
                end_row -= 1
                # Adjust subsequent row references
                white_rows = [r if r < row else r - 1 for r in white_rows]
                yellow_rows = [r if r < row else r - 1 for r in yellow_rows]
                # Don't increment row since we deleted current row
                continue
            row += 1

        white_count = len(white_rows)
        yellow_count = len(yellow_rows)

        self.log_step(f"Found {white_count} white rows, {yellow_count} yellow rows, cyan_found: {cyan_found}")

        # Process based on conditions exactly like VBA
        if has_difference and cyan_found:
            self.log_step("Processing standard split")
            self._process_standard_split(start_row, end_row, end_col, white_rows, yellow_rows)
        else:
            self.log_step("Checking for alternative split conditions")
            should_use_different_logic = False

            # Check for specific conditions exactly like VBA
            for white_row in white_rows:
                col_ab = str(self.ws_result.cell(white_row, 28).value or "").strip()  # Column AB
                col_y = self.ws_result.cell(white_row, 25).value  # Column Y
                col_w = str(self.ws_result.cell(white_row, 23).value or "").strip()  # Column W

                col_y_numeric = isinstance(col_y, (int, float))

                # Conditions exactly like VBA
                condition1 = (col_ab in ["Mexico", "Indonesia", "Canada"] and
                             not col_y_numeric and col_w in ["VL", "TR"])
                condition2 = (col_y_numeric and col_w in ["VL", "TR"])

                if condition1 or condition2:
                    should_use_different_logic = True
                    break

            if should_use_different_logic:
                self.log_step("Processing alternative split")
                self._process_alternative_split(start_row, end_row, end_col, white_rows, yellow_rows, cyan_found)
            else:
                self.log_step("No split conditions met, skipping data group processing")

    def _process_standard_split(self, start_row, end_row, end_col, white_rows, yellow_rows):
        """Process standard split - exact VBA equivalent"""
        new_row = start_row
        insert_count = 0

        for i, white_row in enumerate(white_rows):
            # Copy white row exactly like VBA
            self._copy_row(white_row, new_row)
            new_row += 1
            insert_count += 1

            # Copy all yellow rows for each white row exactly like VBA
            for j, yellow_row in enumerate(yellow_rows):
                self._copy_row(yellow_row, new_row)

                # Update columns N and S exactly like VBA
                self.ws_result.cell(new_row, 14).value = self.ws_result.cell(white_row, 14).value
                self.ws_result.cell(new_row, 19).value = self.ws_result.cell(white_row, 19).value

                # Handle column AK logic exactly like VBA
                if self.ws_result.cell(new_row, end_col - 1).value is not None:
                    for k in range(31, end_col):  # Columns AE to AK
                        self.ws_result.cell(new_row, k).value = self.ws_result.cell(white_row, k).value

                # Handle multiple yellow rows logic exactly like VBA
                if j > 1:
                    for k in range(31, end_col - 1):
                        if self.ws_result.cell(white_row, k).value is None:
                            self.ws_result.cell(new_row, k).value = ""

                new_row += 1
                insert_count += 1

            # Insert separator row exactly like VBA
            if i < len(white_rows) - 1:
                self.ws_result.insert_rows(new_row)
                for col in range(1, end_col):
                    self.ws_result.cell(new_row, col).fill = PatternFill(
                        start_color=self.colors['BLACK'], end_color=self.colors['BLACK'], fill_type="solid")
                self.ws_result.row_dimensions[new_row].height = 5
                new_row += 1
                insert_count += 1

        # Delete original rows exactly like VBA
        if new_row <= end_row + insert_count:
            delete_count = end_row + insert_count - new_row + 1
            self.ws_result.delete_rows(new_row, delete_count)
            self.log_step(f"Deleted {delete_count} original rows")

    def _process_alternative_split(self, start_row, end_row, end_col, white_rows, yellow_rows, cyan_found):
        """Process alternative split - exact VBA equivalent"""
        # Check if white rows have different values in column D
        distinct_white_col_d_values = set()
        for white_row in white_rows:
            d_value = self.ws_result.cell(white_row, 4).value  # Column D
            distinct_white_col_d_values.add(d_value)

        has_difference = len(distinct_white_col_d_values) > 1 or cyan_found

        if has_difference:
            new_row = start_row
            insert_count = 0

            # Process white rows grouped by column D values
            for d_value in distinct_white_col_d_values:
                # Process all white rows with this value in column D
                for white_row in white_rows:
                    if self.ws_result.cell(white_row, 4).value == d_value:
                        # Copy the white row
                        self._copy_row(white_row, new_row)
                        new_row += 1
                        insert_count += 1

                        # Copy all yellow rows for each white row
                        for yellow_row in yellow_rows:
                            self._copy_row(yellow_row, new_row)
                            self.ws_result.cell(new_row, 14).value = self.ws_result.cell(white_row, 14).value
                            self.ws_result.cell(new_row, 19).value = self.ws_result.cell(white_row, 19).value

                            # Same AK column logic as before
                            if self.ws_result.cell(new_row, end_col - 1).value is not None:
                                for k in range(31, end_col):
                                    self.ws_result.cell(new_row, k).value = self.ws_result.cell(white_row, k).value

                            if len(yellow_rows) > 1:
                                for k in range(31, end_col - 1):
                                    if self.ws_result.cell(white_row, k).value is None:
                                        self.ws_result.cell(new_row, k).value = ""

                            new_row += 1
                            insert_count += 1

                # Insert separator row after processing all white rows with this D value
                if d_value != list(distinct_white_col_d_values)[-1]:  # Not the last value
                    self.ws_result.insert_rows(new_row)
                    for col in range(1, end_col):
                        self.ws_result.cell(new_row, col).fill = PatternFill(
                            start_color=self.colors['BLACK'], end_color=self.colors['BLACK'], fill_type="solid")
                    self.ws_result.row_dimensions[new_row].height = 5
                    new_row += 1
                    insert_count += 1

            # Delete original rows
            if new_row <= end_row + insert_count:
                delete_count = end_row + insert_count - new_row + 1
                self.ws_result.delete_rows(new_row, delete_count)

    def _add_new_column(self):
        """Add new columns - exact VBA equivalent"""
        self.log_step("Adding new columns")

        # Insert 5 columns at position E exactly like VBA
        self.ws_result.insert_cols(5, 5)

        # Set new column headers exactly like VBA
        new_headers = {
            5: "Job Number",
            6: "Product Type",
            7: "VNFOB",
            8: "Destination",
            9: "Blind Buy Job #"
        }

        for col, header in new_headers.items():
            self.ws_result.cell(1, col).value = header

        # Insert 1 column at position P exactly like VBA
        self.ws_result.insert_cols(16, 1)
        self.ws_result.cell(1, 16).value = "Estimate BusWeekDate"

        # Update column references exactly like VBA
        self.col_po += 5
        self.col_trading_co_po += 5
        self.col_po_line += 5
        self.col_ogac += 6
        self.col_doc_type_code += 6
        self.col_transportation += 6
        self.col_ptr += 6
        self.col_ship_to_cus_no += 6
        self.col_ship_to_cus_name += 6
        self.col_country += 6
        self.col_inventory_segment_code += 6
        self.col_sub_category_desc += 6

        self.max_col += 6
        self.max_row = self.ws_result.max_row

        # Populate new columns exactly like VBA
        for row in range(self.start_row, self.max_row + 1):
            # Set default VNFOB as "N" exactly like VBA
            if self.ws_result.cell(row, self.col_style).value:
                self.ws_result.cell(row, 7).value = "N"

            # Calculate BusWeekDate exactly like VBA
            ogac_val = self.ws_result.cell(row, self.col_ogac).value
            if ogac_val:
                try:
                    if isinstance(ogac_val, str):
                        # Parse date from string exactly like VBA
                        if "/" in ogac_val:
                            parts = ogac_val.split("/")
                            if len(parts) == 3:
                                month, day, year = int(parts[0]), int(parts[1]), int(parts[2])
                                ogac_date = datetime(year, month, day)
                            else:
                                continue
                        else:
                            continue
                    else:
                        # Assume it's already a date
                        ogac_date = ogac_val

                    # Calculate BusWeekDate exactly like VBA (OGAC date - 10 days, then previous Monday)
                    calc_date = ogac_date - timedelta(days=10)
                    days_since_monday = calc_date.weekday()
                    bus_week_date = calc_date - timedelta(days=days_since_monday)

                    self.ws_result.cell(row, 16).value = bus_week_date
                    self.ws_result.cell(row, 16).number_format = 'MM/DD/YYYY'

                except Exception as e:
                    self.log(f"Error calculating BusWeekDate for row {row}: {e}")

            # Handle blind buy job numbers exactly like VBA
            if (self.ws_result.cell(row, self.col_ptr).value == "Total PO Qty" and
                self._blind_buy_contains(self.ws_result.cell(row, self.col_style).value)[0]):

                _, bb_job = self._blind_buy_contains(self.ws_result.cell(row, self.col_style).value)
                self.ws_result.cell(row, 9).value = bb_job
                self.ws_result.cell(row + 1, 9).value = bb_job
                self.ws_result.cell(row + 2, 9).value = bb_job

    def _remove_column(self):
        """Remove unnecessary columns - exact VBA equivalent"""
        self.log_step("Removing columns")

        self.max_row = self.ws_result.max_row

        row = self.start_row
        while row <= self.max_row:
            # Remove rows with "Total Item Qty" exactly like VBA
            if self.ws_result.cell(row, self.col_ptr).value == "Total Item Qty":
                self.ws_result.delete_rows(row + 1, 2)
                self.max_row -= 2

            # Format cells exactly like VBA
            if not self.ws_result.cell(row, self.max_col + 1).value:
                self._apply_cell_format(row, self.max_col + 1, border_only=True)

            # Clean up style values in summary rows exactly like VBA
            ptr_val = self.ws_result.cell(row, self.col_ptr).value
            if ptr_val in ["Total Style Qty", "Total PO Qty"]:
                for offset in range(3):
                    style_val = str(self.ws_result.cell(row + offset, self.col_style).value or "")
                    if "-" in style_val:
                        self.ws_result.cell(row + offset, self.col_style).value = style_val.split("-")[0]

            if ptr_val == "Total OGAC Qty":
                style_val = str(self.ws_result.cell(row, self.col_style).value or "")
                if "-" in style_val:
                    self.ws_result.cell(row, self.col_style).value = style_val.split("-")[0]

            row += 1

    def _revert_to_obs(self):
        """Revert to OBS format - exact VBA equivalent"""
        self.log_step("Reverting to OBS format")

        self.max_row = self.ws_result.max_row

        for row in range(self.start_row, self.max_row):
            # Add '#' to empty customer fields exactly like VBA
            ptr_val = str(self.ws_result.cell(row, self.col_ptr).value or "")
            ship_no = self.ws_result.cell(row, self.col_ship_to_cus_no).value
            ship_name = self.ws_result.cell(row, self.col_ship_to_cus_name).value

            if ((ship_no is None or str(ship_no).strip() == "") and
                (ship_name is None or str(ship_name).strip() == "") and
                ptr_val not in ["Total PO Qty", "Total OGAC Qty", "Total Colorway Qty", "Total Style Qty", ""]):

                self.ws_result.cell(row, self.col_ship_to_cus_no).value = "#"
                self.ws_result.cell(row, self.col_ship_to_cus_name).value = "#"

            # Add '-' to empty Trading Co PO exactly like VBA
            trading_po = self.ws_result.cell(row, self.col_trading_co_po).value
            style_val = self.ws_result.cell(row, self.col_style).value
            if (trading_po is None or str(trading_po).strip() == "") and style_val:
                self.ws_result.cell(row, self.col_trading_co_po).value = "-"

            # Convert dates to text format exactly like VBA
            self._convert_date_to_text(row, 15)  # Column O
            self._convert_date_to_text(row, 16)  # Column P
            self._convert_date_to_text(row, self.col_ogac)  # OGAC column

        # Rename headers for compatibility exactly like VBA
        header_renames = {
            self.col_style: "Material",
            self.col_ship_to_cus_name: "Customer Name",
            self.col_inventory_segment_code: "AFS Category",
            self.col_sub_category_desc: "Sub Category Size Value",
            self.col_doc_type_code: "Buy Group",
            self.col_vendor: "Vendor",
            self.col_season_code: "Planning Season",
            self.col_season_year: "Year",
            self.col_po: "PO Number",
            self.col_ogac: "OGAC Date",
            self.col_transportation: "Mode"
        }

        for col, new_name in header_renames.items():
            self.ws_result.cell(1, col).value = new_name

        # Insert 2 rows at top exactly like VBA
        self.ws_result.insert_rows(1, 2)

        # Add summary headers exactly like VBA
        self.ws_result.cell(2, self.max_col).value = "Overall Result"
        self.ws_result.cell(3, self.max_col).value = "TOTAL"

        # Insert column after customer name exactly like VBA
        self.ws_result.insert_cols(self.col_ship_to_cus_name + 1, 1)

    # Helper methods for exact VBA replication
    def _get_max_col(self, ws):
        """Get the last used column - exact VBA equivalent"""
        max_col = 1
        for row in ws.iter_rows():
            for cell in reversed(row):
                if cell.value is not None:
                    max_col = max(max_col, cell.column)
                    break
        return max_col

    def _get_row_values(self, row):
        """Get key values from a row for comparison - exact VBA equivalent"""
        return {
            'season_code': str(self.ws_result.cell(row, self.col_season_code).value or ""),
            'season_year': str(self.ws_result.cell(row, self.col_season_year).value or ""),
            'style': str(self.ws_result.cell(row, self.col_style).value or ""),
            'po': str(self.ws_result.cell(row, self.col_po).value or ""),
            'po_line': str(self.ws_result.cell(row, self.col_po_line).value or ""),
            'ship_no': str(self.ws_result.cell(row, self.col_ship_to_cus_no).value or ""),
            'ship_name': str(self.ws_result.cell(row, self.col_ship_to_cus_name).value or ""),
            'total_qty': str(self.ws_result.cell(row, self.col_total_size_qty).value or "")
        }

    def _rows_match(self, row1, row2):
        """Check if two rows match for grouping - exact VBA equivalent"""
        return (row1['season_code'] == row2['season_code'] and
                row1['season_year'] == row2['season_year'] and
                row1['style'] == row2['style'] and
                row1['po'] == row2['po'] and
                row1['po_line'] == row2['po_line'] and
                row1['ship_no'] == row2['ship_no'] and
                row1['ship_name'] == row2['ship_name'] and
                row1['total_qty'] == row2['total_qty'])

    def _copy_row(self, src_row, dst_row):
        """Copy row contents - exact VBA equivalent"""
        for col in range(1, self.max_col + 1):
            self.ws_result.cell(dst_row, col).value = self.ws_result.cell(src_row, col).value
            # Copy formatting if possible
            src_cell = self.ws_result.cell(src_row, col)
            dst_cell = self.ws_result.cell(dst_row, col)
            if src_cell.fill:
                dst_cell.fill = copy.copy(src_cell.fill)
            if src_cell.font:
                dst_cell.font = copy.copy(src_cell.font)
            if src_cell.border:
                dst_cell.border = copy.copy(src_cell.border)

    def _cleanup_empty_rows(self, check_col):
        """Remove rows with empty values - exact VBA equivalent"""
        row = self.start_row
        while row <= self.max_row:
            if not self.ws_result.cell(row, check_col).value:
                self.ws_result.delete_rows(row)
                self.max_row -= 1
            else:
                row += 1

    def _move_column(self, src_col, dst_col):
        """Move column - exact VBA equivalent"""
        # Get all data from source column
        src_data = []
        for row in range(1, self.max_row + 1):
            src_data.append(self.ws_result.cell(row, src_col).value)

        # Insert at destination
        self.ws_result.insert_cols(dst_col)

        # Copy data to new location
        for row, value in enumerate(src_data, 1):
            self.ws_result.cell(row, dst_col).value = value

        # Delete original column
        if src_col > dst_col:
            self.ws_result.delete_cols(src_col + 1)
        else:
            self.ws_result.delete_cols(src_col)

    def _adjust_column_references(self):
        """Adjust column references - exact VBA equivalent"""
        self.col_size_desc += 1
        self.col_size_qty += 1
        self.col_total_size_qty += 1
        self.col_fob += 1
        self.col_ptr = self.col_ship_to_cus_no
        self.col_ship_to_cus_no += 1
        self.col_ship_to_cus_name += 1
        self.col_country += 1
        self.col_inventory_segment_code += 1
        self.col_sub_category_desc += 1
        self.size_col_start -= 3

    def _apply_cell_format(self, row, col, border_only=False):
        """Apply cell formatting - exact VBA equivalent"""
        cell = self.ws_result.cell(row, col)

        # Apply border exactly like VBA
        thin_border = Border(
            left=Side(style='thin', color='D9D9D9'),
            right=Side(style='thin', color='D9D9D9'),
            top=Side(style='thin', color='D9D9D9'),
            bottom=Side(style='thin', color='D9D9D9')
        )
        cell.border = thin_border

        if not border_only:
            cell.fill = PatternFill(start_color="FFFFFF", end_color="FFFFFF", fill_type="solid")

    def _convert_date_to_text(self, row, col):
        """Convert date to text format - exact VBA equivalent"""
        cell = self.ws_result.cell(row, col)
        if cell.value:
            try:
                if isinstance(cell.value, (datetime, date)):
                    text_date = cell.value.strftime("%m/%d/%Y")
                    cell.value = text_date
                cell.number_format = '@'  # Text format
            except:
                cell.number_format = 'General'

    def _get_style_head(self, row):
        """Get style head (part before dash) - exact VBA equivalent"""
        style_val = str(self.ws_result.cell(row, self.col_style).value or "")
        if "-" in style_val:
            return style_val.split("-")[0]
        return style_val

    def _get_colorway(self, row):
        """Get colorway (part after dash) - exact VBA equivalent"""
        style_val = str(self.ws_result.cell(row, self.col_style).value or "")
        if "-" in style_val:
            parts = style_val.split("-")
            if len(parts) > 1:
                return parts[1]
        return style_val

    def _get_cell_color(self, row, col):
        """Get cell color - exact VBA equivalent"""
        cell = self.ws_result.cell(row, col)
        if cell.fill and cell.fill.start_color.rgb:
            return cell.fill.start_color.rgb
        return self.colors['WHITE']

    def _apply_formatting_range(self, start_row, end_row, start_col, end_col, fill_color=None, bold=False):
        """Apply formatting to range - exact VBA equivalent"""
        for row in range(start_row, end_row + 1):
            for col in range(start_col, end_col + 1):
                self._apply_formatting_cell(row, col, fill_color, bold)

    def _apply_formatting_cell(self, row, col, fill_color=None, bold=False):
        """Apply formatting to cell - exact VBA equivalent"""
        cell = self.ws_result.cell(row, col)
        if fill_color:
            cell.fill = PatternFill(start_color=fill_color, end_color=fill_color, fill_type="solid")
        if bold:
            cell.font = Font(bold=True)

    def _blind_buy_contains(self, style_val):
        """Check if style is in blind buy collection - exact VBA equivalent"""
        if not style_val:
            return False, ""
        style_upper = str(style_val).strip().upper()
        for item in self.blind_buy_col:
            if item.sc == style_upper:
                return True, item.bbj
        return False, ""

# UI Implementation
class MainWidget(QWidget):
    log_message = Signal(str)
    processing_done = Signal(int, int, str)

    def __init__(self):
        super().__init__()
        self.setObjectName("dpom_sorter_widget")
        self._build_ui()
        self._connect_signals()

    def _build_ui(self):
        # DEFINE WIDGETS
        self.desc_label = QLabel("DPOM Sorting Tool - Complete 1-to-1 VBA Migration\n\nThis tool provides exact replication of the original VBA macro functionality including all sorting, grouping, formatting, and data transformation operations.", self)
        self.desc_label.setWordWrap(True)
        self.desc_label.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)
        self.desc_label.setAlignment(Qt.AlignLeft | Qt.AlignTop)
        self.desc_label.setTextInteractionFlags(Qt.TextSelectableByMouse)
        self.desc_label.setStyleSheet(
            "color: #dcdcdc; background: transparent; padding: 6px; "
            "border: 1px solid #3a3a3a; border-radius: 6px;"
        )

        self.select_btn2 = PrimaryPushButton("Select Size Excel", self)
        self.select_btn = PrimaryPushButton("Select Raw DPOM Excel Files", self)
        self.run_btn = PrimaryPushButton("Run", self)

        self.files_label = QLabel("Selected DPOM files", self)
        self.files_label.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)
        self.files_label.setStyleSheet("color: #dcdcdc; background: transparent; padding-left: 2px;")
        self.logs_label = QLabel("Process logs", self)
        self.logs_label.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)
        self.logs_label.setStyleSheet("color: #dcdcdc; background: transparent; padding-left: 2px;")

        self.files_box = QTextEdit(self)
        self.files_box.setReadOnly(True)
        self.files_box.setPlaceholderText("Selected DPOM files will appear here")
        self.files_box.setStyleSheet(
            "QTextEdit{background: #1f1f1f; color: #d0d0d0; "
            "border: 1px solid #3a3a3a; border-radius: 6px;}"
        )

        self.files_box2 = QTextEdit(self)
        self.files_box2.setReadOnly(True)
        self.files_box2.setMaximumHeight(50)
        self.files_box2.setPlaceholderText("Selected size file will appear here")
        self.files_box2.setStyleSheet(
            "QTextEdit{background: #1f1f1f; color: #d0d0d0; "
            "border: 1px solid #3a3a3a; border-radius: 6px;}"
        )

        self.log_box = QTextEdit(self)
        self.log_box.setReadOnly(True)
        self.log_box.setPlaceholderText("Live process log will appear here")
        self.log_box.setStyleSheet(
            "QTextEdit{background: #1f1f1f; color: #d0d0d0; "
            "border: 1px solid #3a3a3a; border-radius: 6px;}"
        )

        # CONSTRUCT LAYOUTS
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(16, 16, 16, 16)
        main_layout.setSpacing(12)

        main_layout.addWidget(self.desc_label, 1)

        row1_layout = QHBoxLayout()
        row1_layout.addStretch(1)
        row1_layout.addWidget(self.select_btn2, 1)
        row1_layout.addStretch(1)
        main_layout.addLayout(row1_layout, 0)

        row2_layout = QHBoxLayout()
        row2_layout.addWidget(self.files_box2, 1)
        main_layout.addLayout(row2_layout, 0)

        row3_layout = QHBoxLayout()
        row3_layout.addWidget(self.select_btn, 1)
        row3_layout.addWidget(self.run_btn, 1)
        main_layout.addLayout(row3_layout, 0)

        row4_layout = QHBoxLayout()
        row4_layout.addWidget(self.files_label, 1)
        row4_layout.addWidget(self.logs_label, 1)
        main_layout.addLayout(row4_layout, 0)

        row5_layout = QHBoxLayout()
        row5_layout.addWidget(self.files_box, 1)
        row5_layout.addWidget(self.log_box, 1)
        main_layout.addLayout(row5_layout, 4)

    def _connect_signals(self):
        self.select_btn2.clicked.connect(self.select_size_file)
        self.select_btn.clicked.connect(self.select_files)
        self.run_btn.clicked.connect(self.run_process)
        self.log_message.connect(self.append_log)
        self.processing_done.connect(self.on_processing_done)

    def select_size_file(self):
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select Size / Blind Buy workbook",
            "",
            "Excel Files (*.xlsx *.xls)"
        )
        if file_path:
            self.files_box2.setPlainText(file_path)
        else:
            self.files_box2.clear()

    def _selected_size_file(self) -> str:
        text = self.files_box2.toPlainText().strip()
        return text

    def select_files(self):
        files, _ = QFileDialog.getOpenFileNames(
            self,
            "Select DPOM Excel Files",
            "",
            "Excel Files (*.xlsx *.xls)"
        )
        if files:
            self.files_box.setPlainText("\n".join(files))
        else:
            self.files_box.clear()

    def _selected_files(self) -> List[str]:
        text = self.files_box.toPlainText().strip()
        if not text:
            return []
        return [line for line in text.split("\n") if line.strip()]

    def run_process(self):
        size_file = self._selected_size_file()
        if not size_file:
            MessageBox("Warning", "Size / Blind Buy workbook not selected.", self).exec()
            return

        files = self._selected_files()
        if not files:
            MessageBox("Warning", "No DPOM files selected.", self).exec()
            return

        self.log_box.clear()
        self.log_message.emit(f"Process starting at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        self.log_message.emit(f"Processing {len(files)} DPOM file(s) with size file: {os.path.basename(size_file)}")
        self.run_btn.setEnabled(False)
        self.select_btn.setEnabled(False)

        def worker():
            ok, fail = 0, 0
            output_paths = []

            for file_path in files:
                try:
                    self.log_message.emit(f"\n=== Processing: {os.path.basename(file_path)} ===")

                    processor = DPOMProcessor(self.log_message.emit)
                    success = processor.process_ss(file_path, size_file)

                    if success:
                        output_dir = os.path.dirname(file_path)
                        filename = os.path.basename(file_path)
                        name, ext = os.path.splitext(filename)
                        output_path = os.path.join(output_dir, f"{name}_processed{ext}")

                        processor.wb_dpom.save(output_path)
                        processor.wb_dpom.close()

                        output_paths.append(output_path)
                        ok += 1
                        self.log_message.emit(f" Successfully processed: {filename}")
                    else:
                        fail += 1
                        self.log_message.emit(f" Failed to process: {filename}")

                except Exception as e:
                    fail += 1
                    self.log_message.emit(f" Error processing {os.path.basename(file_path)}: {str(e)}")
                    import traceback
                    self.log_message.emit(f"Traceback: {traceback.format_exc()}")

            output_info = ", ".join([os.path.basename(p) for p in output_paths]) if output_paths else ""
            self.processing_done.emit(ok, fail, output_info)

        threading.Thread(target=worker, daemon=True).start()

    def append_log(self, text: str):
        self.log_box.append(text)
        self.log_box.ensureCursorVisible()

    def on_processing_done(self, ok: int, fail: int, out_path: str):
        if out_path:
            self.log_message.emit(f"\nOutput files: {out_path}")
        self.log_message.emit(f"\nCompleted: {ok} success, {fail} failed.")
        self.log_message.emit(f"Finished at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        self.run_btn.setEnabled(True)
        self.select_btn.setEnabled(True)

def get_widget():
    return MainWidget()

def process_files(size_file: str, dpom_files: List[str], log_callback) -> tuple:
    """Legacy function for backward compatibility"""
    ok, fail = 0, 0
    output_paths = []

    for file_path in dpom_files:
        try:
            log_callback(f"Processing: {os.path.basename(file_path)}")

            processor = DPOMProcessor(log_callback)
            success = processor.process_ss(file_path, size_file)

            if success:
                output_dir = os.path.dirname(file_path)
                filename = os.path.basename(file_path)
                name, ext = os.path.splitext(filename)
                output_path = os.path.join(output_dir, f"{name}_processed{ext}")

                processor.wb_dpom.save(output_path)
                processor.wb_dpom.close()

                output_paths.append(output_path)
                ok += 1
            else:
                fail += 1

        except Exception as e:
            fail += 1
            log_callback(f"Error: {str(e)}")

    output_info = output_paths[0] if output_paths else ""
    return output_info, ok, fail

if __name__ == "__main__":
    print("DPOM Sorting Tool - Complete 1-to-1 VBA Migration")
    print("This module provides exact replication of the original VBA macro functionality.")